import pandas
import numpy
from scipy.interpolate import InterpolatedUnivariateSpline
import os


def read_COMSOL_csv(file_path, name_list=[]):
    """ Reads simulation result (csv file) generated by COMSOL and returns a pandas DataFrame
    """

    # columns are seperated by comma
    # first 5 lines are skipped
    data = pandas.read_csv(file_path, skiprows=4)

    if name_list:
        data.columns = name_list
    return data


# def get_column_values(dataframe, column_number):
#     some_column = dataframe.iloc[:, column_number]
#     some_values = some_column.value_counts().index
#     return numpy.sort(some_values.values)
#
#
# def get_column_values_by_name(dataframe, column_name):
#     column_list = list(dataframe.columns.values)
#     column_number = column_list.index(column_name)
#     return get_column_values(dataframe, column_number)

def get_sub_dataframe(dataframe, conditions):
    condition_series = [dataframe[key] == value for key, value in conditions.items()]
    condition_final = condition_series[0]
    for series in condition_series[1:]:
        condition_final &= series
    sub_dataframe = dataframe.loc[condition_final]
    return sub_dataframe


# def generate_apcv(dataframe, conditions, target_value):
#     """ Generates approach curve of `target_value` according at given `conditions`
#
#     Parameters
#     ----------
#     dataframe: pandas.DataFrame
#     conditions: dictionary
#     target_value: string
#
#     Returns
#     -------
#     pandas.Series
#     """
#     condition_series = [dataframe[key] == value for key, value in conditions.items()]
#     condition_final = condition_series[0]
#     for series in condition_series[1:]:
#         condition_final &= series
#     sub_dataframe = dataframe.loc[condition_final]
#     apcv = pandas.Series(-1 * sub_dataframe[target_value].values, index=sub_dataframe['tsd'].values)
#     return apcv.sort_index()
#
#
# def extrapolate_apcv(apcv):
#     """ Extrapolate approach curve to tip-sample distance of 0nm
#
#     This function is deprecated especially for approach curve on low dielectric materials
#     """
#     x = apcv.index.values
#     y = apcv.values
#     spl = InterpolatedUnivariateSpline(x, y)
#     xs = numpy.linspace(0, 30 , 3100)
#     ys = numpy.array([spl(i) for i in xs])
#     ys *= -1  # Y21 to Y11
#     return pandas.Series(ys, index=xs)
#
#
# def generate_calibration_curve(sim_data, min_tsd, max_tsd, parameter_list, target_value):
#     from data_analysis import (
#         generate_tsd_time_series, generate_y11_time_series, time_series_fft_amp, detect_1st_peak
#     )
#     parameter_dict = {parameter: get_column_values_by_name(sim_data, parameter) for parameter in parameter_list}
#
#     calibration_curve = pandas.DataFrame()
#
#     if len(parameter_list) == 2:
#         for i in parameter_dict[parameter_list[0]]:
#             y11_list = []
#             for j in parameter_dict[parameter_list[1]]:
#                 conditions = {parameter_list[0]: i, parameter_list[1]: j}
#                 apcv = generate_apcv(sim_data, conditions, target_value)
#                 tsd_series = generate_tsd_time_series(min_tsd, max_tsd)
#                 y11_series = generate_y11_time_series(tsd_series, apcv)
#                 y11_fft = time_series_fft_amp(y11_series)
#                 y11_peak_value = detect_1st_peak(y11_fft)
#                 y11_list.append(y11_peak_value)
#             calibration_curve[i] = y11_list
#         calibration_curve.index = parameter_dict[parameter_list[1]]
#         return calibration_curve
#     elif len(parameter_list) == 1:
#         for i in parameter_dict[parameter_list[0]]:
#             y11_list = []
#             conditions = {parameter_list[0]: i}
#             apcv = generate_apcv(sim_data, conditions, target_value)
#             tsd_series = generate_tsd_time_series(min_tsd, max_tsd)
#             y11_series = generate_y11_time_series(tsd_series, apcv)
#             y11_fft = time_series_fft_amp(y11_series)
#             y11_peak_value = detect_1st_peak(y11_fft)
#             y11_list.append(y11_peak_value)
#             calibration_curve[i] = y11_list
#         return calibration_curve
#
#
# # def generate_calibration_curve_au(sim_data, min_tsd, max_tsd):
# #     from data_analysis import (
# #         generate_tsd_time_series, generate_y11_time_series, time_series_fft_amp, detect_1st_peak
# #     )
# #     tip_radius_list = get_column_values(sim_data, 0)
# #     mtr_epsl_list = get_column_values(sim_data, 2)
# #     calibration_curve = pandas.DataFrame()
# #     for tip_radius in tip_radius_list:
# #         y11_list = []
# #         for mtr_epsl in mtr_epsl_list:
# #             apcv = generate_apcv(sim_data, tip_radius, mtr_epsl)
# #             tsd_series = generate_tsd_time_series(min_tsd, max_tsd)
# #             y11_series = generate_y11_time_series(tsd_series, apcv)
# #             y11_fft = time_series_fft_amp(y11_series)
# #             y11_peak_value = detect_1st_peak(y11_fft)
# #             y11_list.append(y11_peak_value)
# #         calibration_curve[tip_radius] = y11_list
# #     calibration_curve.index = mtr_epsl_list
# #     return calibration_curve
#
#
# def generate_dep_curve(sim_data, min_tsd, max_tsd, conditions, index_var_name, value_var_name):
#     from data_analysis import (
#         generate_tsd_time_series, generate_y11_time_series, time_series_fft_amp, detect_1st_peak
#     )
#     index_var_list = get_column_values_by_name(sim_data, index_var_name)
#     y11_list = []
#     for index_var in index_var_list:
#         conditions[index_var_name] = index_var
#         apcv = generate_apcv(sim_data, conditions, value_var_name)
#         tsd_series = generate_tsd_time_series(min_tsd, max_tsd)
#         y11_series = generate_y11_time_series(tsd_series, apcv)
#         y11_fft = time_series_fft_amp(y11_series)
#         y11_peak_value = detect_1st_peak(y11_fft)
#         y11_list.append(y11_peak_value)
#     dep_curve = pandas.Series(y11_list, index=index_var_list)
#     return dep_curve
#
#
# if __name__ == '__main__':
#     data1 = read_COMSOL_txt('flatend_data_0515.txt')
#     tip_radius_list = get_column_values(data1, 0)
#     mtr_epsl_list = get_column_values(data1, 2)
#     apcv1 = generate_apcv(data1, tip_radius_list[0], mtr_epsl_list[10])
#     apcv1_ext = extrapolate_apcv(apcv1)
#
#     from data_analysis import generate_tsd_time_series, generate_y11_time_series
#     import matplotlib.pyplot as plt
#     tsd_series = generate_tsd_time_series(1, 5)
#     y11_series = generate_y11_time_series(tsd_series, apcv1)
#     y11_series.plot()
#     plt.show()
